import os
import json
import glob
import papermill as pm
from datetime import datetime
from flask import Flask, request, render_template, redirect, url_for, flash
from concurrent.futures import ThreadPoolExecutor

app = Flask(__name__)
app.secret_key = 'secret_key'  # Needed for flash messages

# Directories where JSON outputs are stored
ANALYSIS_FOLDER = os.path.join(os.getcwd(), 'analysis')
DCF_FOLDER = os.path.join(os.getcwd(), 'dcf')
DATA_FOLDER = os.path.join(os.getcwd(), 'data')
TRANSCRIPTS_FOLDER = os.path.join(os.getcwd(), 'transcripts')

def run_analysis(ticker: str) -> bool:
    """
    Runs the parameterized analysis notebook using Papermill with the given ticker.
    Returns True if executed without error.
    """
    try:
        pm.execute_notebook(
            'analyze_stock.ipynb',
            None,
            parameters={'ticker': ticker}
        )
        return True
    except Exception as e:
        print(f"Error running analysis notebook: {e}")
        return False

def load_analysis_data(ticker: str) -> dict:
    """
    Loads the JSON analysis data from the file generated by the analysis notebook.
    Returns an empty dictionary if the file does not exist.
    """
    json_path = os.path.join(ANALYSIS_FOLDER, f'{ticker}.json')
    if os.path.exists(json_path):
        with open(json_path, 'r') as f:
            return json.load(f)
    return {}

def run_dcf(ticker: str, fcf_ps: float, growth_rate: float,
            terminal_multiple: float, years: int, cash: float,
            debt: float, shares: float) -> bool:
    """
    Runs the DCF notebook using Papermill with the given parameters.
    Returns True if executed without error.
    """
    try:
        pm.execute_notebook(
            'dcf.ipynb',
            None,
            parameters={
                'ticker': ticker,
                'fcf_ps': fcf_ps,
                'growth_rate': growth_rate,
                'terminal_multiple': terminal_multiple,
                'years': years,
                'cash': cash,
                'debt': debt,
                'shares': shares
            }
        )
        return True
    except Exception as e:
        print(f"Error running dcf notebook: {e}")
        return False

def load_dcf_data(ticker: str) -> dict:
    """
    Loads the JSON DCF data from the file produced by the DCF notebook.
    Returns an empty dictionary if the file does not exist.
    """
    json_path = os.path.join(DCF_FOLDER, f'{ticker}.json')
    if os.path.exists(json_path):
        with open(json_path, 'r') as f:
            return json.load(f)
    return {}

def run_transcripts(ticker: str) -> bool:
    """
    Runs the transcripts notebook using Papermill for the given ticker.
    The notebook expects a parameter 'ticker_list'.
    """
    try:
        pm.execute_notebook(
            'transcripts.ipynb',
            None,
            parameters={'ticker_list': [ticker]}
        )
        return True
    except Exception as e:
        print(f"Error running transcripts notebook: {e}")
        return False

def load_transcript_data(ticker: str) -> list:
    """
    Searches the transcripts folder for files with the naming convention:
      {ticker}_*_transcript.json
    Loads and returns a list of transcript dictionaries, sorted by year and quarter (newest first).
    """
    pattern = os.path.join(TRANSCRIPTS_FOLDER, f"{ticker}_*_transcript.json")
    files = glob.glob(pattern)
    transcript_list = []
    for filename in files:
        try:
            with open(filename, 'r') as f:
                data = json.load(f)
                # Ensure both year and quarter keys exist; otherwise, skip this file.
                if "year" in data and "quarter" in data:
                    transcript_list.append(data)
        except Exception as e:
            print(f"Error loading transcript file {filename}: {e}")
    # Sort transcripts by year and quarter descending (newest first)
    transcript_list.sort(key=lambda x: (x.get('year', 1900), x.get('quarter', 0)), reverse=True)
    return transcript_list

@app.route('/compute_summary', methods=['POST'])
def compute_summary():
    ticker = request.form.get('ticker', '').upper().strip()
    try:
        year = int(request.form.get('year'))
        quarter = int(request.form.get('quarter'))
    except Exception as e:
        return {"error": "Invalid year or quarter parameter."}, 400

    try:
        # Execute the transcript summary notebook with the given parameters.
        pm.execute_notebook(
            'transcript_summary.ipynb',
            None,
            parameters={'ticker': ticker, 'year': year, 'quarter': quarter}
        )
        # Build the expected output filename: e.g. AAPL_2021_Q1_summary.json
        summary_path = os.path.join(os.getcwd(), 'summaries', f"{ticker}_{year}_Q{quarter}_summary.json")
        if os.path.exists(summary_path):
            with open(summary_path, 'r') as f:
                summary_data = json.load(f)
            # The notebook should output a dict with key "summary"
            return summary_data
        else:
            return {"error": "Summary file not found."}, 500
    except Exception as e:
        return {"error": f"Error generating summary: {str(e)}"}, 500

def delete_cache_files(ticker: str):
    """
    Deletes cached JSON files for the given ticker from the data folder.
    Expected filenames: {ticker}_balance_sheet.json, {ticker}_cash_flow.json, {ticker}_income_statement.json
    """
    filenames = [
        f"{ticker}_balance_sheet.json",
        f"{ticker}_cash_flow.json",
        f"{ticker}_income_statement.json"
    ]
    for filename in filenames:
        file_path = os.path.join(DATA_FOLDER, filename)
        if os.path.exists(file_path):
            try:
                os.remove(file_path)
                print(f"Deleted cache file: {file_path}")
            except Exception as e:
                print(f"Error deleting {file_path}: {e}")

@app.route('/', methods=['GET', 'POST'])
def index():
    if request.method == 'POST':
        ticker = request.form.get('ticker', '').upper().strip()
        if not ticker:
            flash('Ticker symbol is required.')
            return redirect(url_for('index'))

        # Run notebooks concurrently.
        with ThreadPoolExecutor(max_workers=2) as executor:
            future_analysis = executor.submit(run_analysis, ticker)
            future_transcripts = executor.submit(run_transcripts, ticker)
            analysis_ok = future_analysis.result()
            transcripts_ok = future_transcripts.result()

        if not analysis_ok:
            flash('There was an error running the analysis.')
            return redirect(url_for('index'))

        metrics = load_analysis_data(ticker)
        if not metrics:
            flash('Analysis data not found. Please try again.')
            return redirect(url_for('index'))

        # Load transcript data only if the transcripts notebook ran successfully.
        if transcripts_ok:
            transcript_data = load_transcript_data(ticker)
        else:
            flash('There was an error running the transcripts analysis.')
            transcript_data = {}

        # Render the result page.
        return render_template('result.html', ticker=ticker, metrics=metrics, 
                               dcf_results=None, dcf_params=None, transcript_data=transcript_data)

    return render_template('index.html')

@app.route('/compute_dcf', methods=['POST'])
def compute_dcf():
    """
    AJAX-only endpoint to run the DCF notebook with form-supplied parameters.
    Returns a JSON object containing:
      - rendered HTML for the DCF section (which still includes the form)
      - dcf_results JSON data for initializing the Chart.js chart.
    """
    ticker = request.form.get('ticker', '').upper().strip()
    if not ticker:
        return {"error": "Ticker symbol missing for DCF computation."}, 400

    try:
        fcf_ps = float(request.form.get('fcf_ps'))
        growth_rate = float(request.form.get('growth_rate'))
        terminal_multiple = float(request.form.get('terminal_multiple'))
        years = int(request.form.get('years'))
        cash = float(request.form.get('cash'))
        debt = float(request.form.get('debt'))
        shares = float(request.form.get('shares'))
    except Exception as e:
        return {"error": f"Error parsing DCF parameters: {e}"}, 400

    if not run_dcf(ticker, fcf_ps, growth_rate, terminal_multiple, years, cash, debt, shares):
        return {"error": "Error computing DCF. Please try again."}, 500

    metrics = load_analysis_data(ticker)
    dcf_results = load_dcf_data(ticker)
    dcf_params = {
        'fcf_ps': fcf_ps,
        'growth_rate': growth_rate,
        'terminal_multiple': terminal_multiple,
        'years': years,
        'cash': cash,
        'debt': debt,
        'shares': shares,
    }

    # Render the updated DCF partial (which includes both the form and, if available, results)
    dcf_html = render_template('partials/_dcf.html',
                               ticker=ticker,
                               metrics=metrics,
                               dcf_results=dcf_results,
                               dcf_params=dcf_params)
    return {"dcf_html": dcf_html, "dcf_results": dcf_results}

@app.route('/reset_cache', methods=['POST'])
def reset_cache():
    """
    Route to reset the cache for a given ticker by deleting cached JSON files,
    re-running the analysis notebook, and reloading the result page.
    """
    ticker = request.form.get('ticker', '').upper().strip()
    if not ticker:
        flash('Ticker symbol missing for cache reset.')
        return redirect(url_for('index'))

    # Delete cached files from the data folder.
    delete_cache_files(ticker)

    # Re-run the analysis notebook.
    if not run_analysis(ticker):
        flash('Error re-running analysis after cache reset.')
        return redirect(url_for('index'))

    metrics = load_analysis_data(ticker)
    if not metrics:
        flash('Analysis data not found after cache reset.')
        return redirect(url_for('index'))

    return render_template('result.html', ticker=ticker, metrics=metrics, dcf_results=None, dcf_params=None)

if __name__ == '__main__':
    app.run(debug=True)
